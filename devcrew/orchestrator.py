"""Dynamic crew orchestrator built on top of crewAI."""
from __future__ import annotations

import json, time
import logging
import os
import re
from dataclasses import dataclass
from typing import Any, Callable, Dict, List, Optional

from crewai import Agent, Crew, Process, Task
from langchain_core.language_models.chat_models import BaseChatModel
from langchain_core.messages import HumanMessage, SystemMessage
from pydantic import BaseModel, Field, ValidationError

from .tools import ToolRegistry



def step_cb(step_output):
    with open("steps.ndjson", "a") as f:
        f.write(json.dumps({
            "ts": time.time(),
            "type": "step",
            "agent": getattr(step_output, "agent", None),
            "content": str(step_output),
        }, ensure_ascii=False) + "\n")

def task_cb(task_output):
    with open("steps.ndjson", "a") as f:
        f.write(json.dumps({
            "ts": time.time(),
            "type": "task_end",
            "task": getattr(task_output, "description", None),
            "raw": getattr(task_output, "raw_output", None),
        }, ensure_ascii=False) + "\n")

# ---------- Logging sane defaults ----------
logger = logging.getLogger(__name__)
if not logging.getLogger().handlers:
    # Config por defecto si la app no configuró logging
    level = os.getenv("LOG_LEVEL", "INFO").upper()
    logging.basicConfig(
        level=getattr(logging, level, logging.INFO),
        format="[%(levelname)s] %(name)s: %(message)s",
    )


class AgentPlan(BaseModel):
    """Structured definition for an agent coming from the planning step."""

    name: str
    role: str
    goal: str
    backstory: str
    tools: List[str] = Field(default_factory=list)
    allow_delegation: bool = False
    verbose: bool = False
    max_iter: Optional[int] = None


class TaskPlan(BaseModel):
    """Structured definition for a task created by the planner."""

    name: str
    description: str
    expected_output: str
    agent: str
    tools: List[str] = Field(default_factory=list)
    async_execution: bool = False


class CrewPlan(BaseModel):
    """Complete plan generated by the planner model."""

    summary: str
    agents: List[AgentPlan]
    tasks: List[TaskPlan]
    process: str = "sequential"

    def process_enum(self) -> Process:
        mapping = {
            "sequential": Process.sequential,
            "hierarchical": Process.hierarchical,
        }
        return mapping.get(self.process.lower(), Process.sequential)


@dataclass
class BuiltCrew:
    plan: CrewPlan
    crew: Crew


class PlanGenerationError(RuntimeError):
    """Raised when the planner produces an invalid or unparsable response."""


class DynamicCrewOrchestrator:
    """Build and execute crews dynamically based on a single user prompt."""

    def __init__(
        self,
        planner_llm: BaseChatModel,
        agent_llm_factory: Callable[[AgentPlan], BaseChatModel],
        tool_registry: ToolRegistry,
        *,
        planner_instructions: Optional[str] = None,
        verbose: bool = False,
    ) -> None:
        self.planner_llm = planner_llm
        self.agent_llm_factory = agent_llm_factory
        self.tool_registry = tool_registry
        self.verbose = verbose
        self._planner_instructions = planner_instructions or self._default_planner_instructions()

    @staticmethod
    def _default_planner_instructions() -> str:
        return (
            "You are an expert project manager that assembles specialised AI "
            "agents to solve complex problems. Based on the user's problem you "
            "must describe the agents, tasks and tools required to solve it. "
            "Always answer with a JSON object following the schema provided "
            "in the system message."
        )

    def plan(self, prompt: str) -> CrewPlan:
        """Generate a :class:`CrewPlan` for ``prompt`` using the planner LLM."""

        logger.debug("Planning dynamic crew for prompt: %s", prompt)
        sys_msg = SystemMessage(
            content=(
                "You will receive a problem description from the user. "
                "Respond **only** with valid JSON that matches this schema:\n"
                "{\n"
                "  \"summary\": str,\n"
                "  \"process\": str,  // sequential | hierarchical | parallel\n"
                "  \"agents\": [\n"
                "    {\n"
                "      \"name\": str,\n"
                "      \"role\": str,\n"
                "      \"goal\": str,\n"
                "      \"backstory\": str,\n"
                "      \"tools\": [str],\n"
                "      \"allow_delegation\": bool,\n"
                "      \"verbose\": bool,\n"
                "      \"max_iter\": int | null\n"
                "    }\n"
                "  ],\n"
                "  \"tasks\": [\n"
                "    {\n"
                "      \"name\": str,\n"
                "      \"description\": str,\n"
                "      \"expected_output\": str,\n"
                "      \"agent\": str,  // reference to an agent name\n"
                "      \"tools\": [str],\n"
                "      \"async_execution\": bool\n"
                "    }\n"
                "  ]\n"
                "}\n"
                "**Hard requirements**:\n"
                "- Return AT LEAST ONE agent and AT LEAST ONE task.\n"
                "- Every task.agent MUST reference an existing agent name.\n"
                "- Every agent and task MUST include a \"name\" value.\n"
                "- Names must be unique within their section.\n"
                "- If no tool is applicable, set tools to [] (do NOT invent tools).\n"
                "Only include tools that are present in the provided list. "
                "If none of the available tools are useful, return an empty "
                "list for \"tools\".\n\n"
                f"Available tools: {', '.join(self.tool_registry.available())}\n\n"
                f"{self._planner_instructions}"
            )
        )
        response = self.planner_llm.invoke([sys_msg, HumanMessage(content=prompt)])
        raw_plan = getattr(response, "content", response)
        try:
            plan = self._parse_plan(raw_plan)
            logger.info(
                "Plan created | process=%s | agents=%d | tasks=%d",
                plan.process, len(plan.agents), len(plan.tasks)
            )
            if plan.summary:
                logger.info("Plan summary: %s", plan.summary)
            return plan
        except ValidationError as exc:  # pragma: no cover - defensive
            raise PlanGenerationError(
                f"Planner produced invalid plan: {exc}\nRaw response: {raw_plan}"
            ) from exc
        except json.JSONDecodeError as exc:  # pragma: no cover - defensive
            raise PlanGenerationError(
                f"Planner did not return valid JSON. Raw response: {raw_plan}"
            ) from exc

    # -----------------------
    # Parsing / sanitization
    # -----------------------
    @staticmethod
    def _clean_text(text: str) -> str:
        """Remove <think>…</think>, code fences and stray XML/HTML tags around JSON."""
        s = str(text)

        # Remove DeepSeek/Reasoning style tags
        s = re.sub(r"<think>.*?</think>", "", s, flags=re.DOTALL | re.IGNORECASE)

        # Remove generic XML/HTML-ish tags that are not part of JSON
        s = re.sub(r"</?[A-Za-z][A-Za-z0-9:_\-.]*[^>]*>", "", s)

        # Strip code fences ```...```
        s = re.sub(r"```(json)?", "", s, flags=re.IGNORECASE)

        # Trim whitespace
        s = s.strip()
        return s

    @staticmethod
    def _extract_first_json_object(text: str) -> str:
        """
        Return the first balanced top-level JSON object found in text.
        Ignores braces inside string literals and handles escapes.
        Raises JSONDecodeError if none found.
        """
        s = text
        depth = 0
        in_str = False
        escape = False
        start_idx = -1

        for i, ch in enumerate(s):
            if in_str:
                if escape:
                    escape = False
                elif ch == "\\":
                    escape = True
                elif ch == '"':
                    in_str = False
                continue

            if ch == '"':
                in_str = True
                continue

            if ch == "{":
                if depth == 0:
                    start_idx = i
                depth += 1
            elif ch == "}":
                if depth > 0:
                    depth -= 1
                    if depth == 0 and start_idx != -1:
                        candidate = s[start_idx : i + 1]
                        try:
                            json.loads(candidate)
                            return candidate
                        except json.JSONDecodeError:
                            pass

        raise json.JSONDecodeError("No valid JSON object found", s, 0)

    @staticmethod
    def _coerce_name(value: str) -> str:
        if not isinstance(value, str):
            value = str(value)
        return re.sub(r"\s+", " ", value).strip()

    @staticmethod
    def _ensure_unique_name(base: str, *, used: set[str]) -> str:
        name = DynamicCrewOrchestrator._coerce_name(base) or "Unnamed"
        candidate = name
        suffix = 2
        while candidate in used:
            candidate = f"{name} ({suffix})"
            suffix += 1
        used.add(candidate)
        return candidate

    def _normalise_plan_payload(self, data: dict[str, Any]) -> dict[str, Any]:
        if not isinstance(data, dict):
            return data

        normalised: dict[str, Any] = dict(data)

        agents_raw = data.get("agents") or []
        agents: List[dict[str, Any]] = []
        used_agent_names: set[str] = set()
        agent_names: List[str] = []
        alias_map: dict[str, str] = {}

        for idx, raw in enumerate(list(agents_raw)):
            if isinstance(raw, dict):
                agent_dict = dict(raw)
            elif isinstance(raw, str):
                agent_dict = {"role": raw}
            else:
                continue

            candidates = [
                self._coerce_name(agent_dict.get("name", "")),
                self._coerce_name(agent_dict.get("role", "")),
                f"Agent {idx + 1}",
            ]
            base_name = next((c for c in candidates if c), "Agent")
            name = self._ensure_unique_name(base_name, used=used_agent_names)
            agent_dict["name"] = name

            if not agent_dict.get("role"):
                agent_dict["role"] = name

            for label in {agent_dict.get("name"), agent_dict.get("role"), candidates[0]}:
                coerced = self._coerce_name(label) if label else ""
                if coerced:
                    alias_map.setdefault(coerced.lower(), name)

            agents.append(agent_dict)
            agent_names.append(name)

        if agents:
            normalised["agents"] = agents

        tasks_raw = data.get("tasks") or []
        tasks: List[dict[str, Any]] = []
        used_task_names: set[str] = set()

        for idx, raw in enumerate(list(tasks_raw)):
            if isinstance(raw, dict):
                task_dict = dict(raw)
            elif isinstance(raw, str):
                task_dict = {"description": raw}
            else:
                continue

            candidates = [
                self._coerce_name(task_dict.get("name", "")),
                self._coerce_name(task_dict.get("description", "")),
                f"Task {idx + 1}",
            ]
            base_name = next((c for c in candidates if c), "Task")
            name = self._ensure_unique_name(base_name, used=used_task_names)
            task_dict["name"] = name

            agent_ref = self._coerce_name(task_dict.get("agent", ""))
            if agent_ref:
                mapped = alias_map.get(agent_ref.lower())
                if not mapped:
                    mapped = next(
                        (a for a in agent_names if a.lower() == agent_ref.lower()),
                        None,
                    )
                if mapped:
                    task_dict["agent"] = mapped
            if not task_dict.get("agent") and agent_names:
                task_dict["agent"] = agent_names[0]

            tasks.append(task_dict)

        if tasks:
            normalised["tasks"] = tasks

        return normalised

    def _parse_plan(self, raw_plan: Any) -> CrewPlan:
        if isinstance(raw_plan, CrewPlan):
            return raw_plan
        if isinstance(raw_plan, dict):
            data = raw_plan
        else:
            text = self._clean_text(str(raw_plan))
            # Try direct parse first
            try:
                data = json.loads(text)
            except json.JSONDecodeError:
                # Extract the first valid object inside the text (handles "Extra data")
                json_str = self._extract_first_json_object(text)
                data = json.loads(json_str)

        normalised = self._normalise_plan_payload(data)
        plan = CrewPlan.model_validate(normalised)
        return plan

    # -----------------------
    # Fallbacks / build crew
    # -----------------------
    def _fallback_agent_plan(self, plan: CrewPlan) -> AgentPlan:
        """Crea un AgentPlan de respaldo cuando el planner no devuelve agentes."""
        summary = getattr(plan, "summary", "") or "Solve the user's problem"
        return AgentPlan(
            name="Generalist",
            role="Generalist Agent",
            goal=f"Analyze the problem and execute tasks to resolve it. Summary: {summary}",
            backstory="Fallback agent injected because planner returned no agents.",
            tools=[],
            allow_delegation=False,
            verbose=self.verbose,
            max_iter=5,
        )

    def build_crew(self, plan: CrewPlan) -> BuiltCrew:
        """Instantiate crewAI objects based on ``plan``."""

        # Validaciones previas
        if not plan.tasks:
            raise PlanGenerationError("Planner returned no tasks; cannot build a crew.")

        if not plan.agents:
            logger.warning("Planner returned no agents; injecting fallback 'Generalist'.")
            plan.agents = [self._fallback_agent_plan(plan)]

        agent_lookup: Dict[str, Agent] = {}
        for agent_plan in plan.agents:
            tools = [
                self.tool_registry.get(tool_name)
                for tool_name in agent_plan.tools
                if self.tool_registry.has(tool_name)
            ]
            if missing := [
                name for name in agent_plan.tools if not self.tool_registry.has(name)
            ]:
                logger.warning("Ignoring unknown tools for agent %s: %s", agent_plan.name, missing)
            agent = Agent(
                name=agent_plan.name,
                role=agent_plan.role,
                goal=agent_plan.goal,
                backstory=agent_plan.backstory,
                allow_delegation=agent_plan.allow_delegation,
                verbose=agent_plan.verbose or self.verbose,
                tools=tools,
                llm=self.agent_llm_factory(agent_plan),
                max_iter=agent_plan.max_iter if agent_plan.max_iter is not None else 5,
            )
            try:
                # si es crewai.LLM
                llm_model = getattr(agent.llm, "model", None)
                logger.info("Agent '%s' using LLM model: %s", agent_plan.name, llm_model)
            except Exception:
                pass

            agent_lookup[agent_plan.name] = agent

        tasks: List[Task] = []
        first_agent = next(iter(agent_lookup.values()))
        for task_plan in plan.tasks:
            assigned_agent = agent_lookup.get(task_plan.agent)
            if assigned_agent is None:
                logger.warning(
                    "Task '%s' references unknown agent '%s'. Reassigning to '%s'.",
                    task_plan.name, task_plan.agent, first_agent.name
                )
                assigned_agent = first_agent
            task_tools = [
                self.tool_registry.get(tool_name)
                for tool_name in task_plan.tools
                if self.tool_registry.has(tool_name)
            ]
            task = Task(
                name=task_plan.name,
                description=task_plan.description,
                expected_output=task_plan.expected_output,
                agent=assigned_agent,
                tools=task_tools or None,
                async_execution=task_plan.async_execution,
            )
            tasks.append(task)

        crew = Crew(
            agents=list(agent_lookup.values()),
            tasks=tasks,
            process=plan.process_enum(),
            verbose=self.verbose,
            output_log_file="run.json",
            step_callback=step_cb,
            task_callback=task_cb,
        )
        return BuiltCrew(plan=plan, crew=crew)

    def plan_and_build(self, prompt: str) -> BuiltCrew:
        """Convenience helper that plans and immediately builds a crew."""

        plan = self.plan(prompt)
        return self.build_crew(plan)

    def kickoff(
        self,
        built: BuiltCrew,
        prompt: str,
        *,
        kickoff_inputs: Optional[Dict[str, Any]] = None,
    ) -> Dict[str, Any]:
        """Kick off an already planned and built crew."""

        plan = built.plan
        inputs = {"problem": prompt}
        if kickoff_inputs:
            inputs.update(kickoff_inputs)

        result = built.crew.kickoff(inputs=inputs)

        # ---------- Resultado robusto ----------
        # Algunas versiones de crewAI devuelven objetos o None. Intentamos ofrecer
        # siempre algo imprimible y útil.
        def _task_output_to_str(t: Task) -> Optional[str]:
            for attr in ("output", "result", "output_str"):
                val = getattr(t, attr, None)
                if val:
                    return str(val)
            return None

        if not result or (isinstance(result, str) and not result.strip()):
            collected: List[str] = []
            for t in built.crew.tasks:
                out = _task_output_to_str(t)
                if out:
                    collected.append(f"[{t.name}] {out}")
            if collected:
                result = "\n\n".join(collected)
            else:
                # Último recurso: un resumen estructurado del plan
                result = (
                    "No textual result from crew.kickoff().\n"
                    f"Plan: process={plan.process}, agents={len(plan.agents)}, tasks={len(plan.tasks)}"
                )

        return {"plan": plan, "result": result}

    def run(self, prompt: str, *, kickoff_inputs: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Plan, build and execute a crew to respond to ``prompt``."""

        built = self.plan_and_build(prompt)
        return self.kickoff(built, prompt, kickoff_inputs=kickoff_inputs)
