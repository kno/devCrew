"""Dynamic crew orchestrator built on top of crewAI."""
from __future__ import annotations

import json
import logging
from dataclasses import dataclass
from typing import Any, Callable, Dict, List, Optional

from crewai import Agent, Crew, Process, Task
from langchain_core.language_models.chat_models import BaseChatModel
from langchain_core.messages import HumanMessage, SystemMessage
from pydantic import BaseModel, Field, ValidationError

from .tools import ToolRegistry

logger = logging.getLogger(__name__)


class AgentPlan(BaseModel):
    """Structured definition for an agent coming from the planning step."""

    name: str
    role: str
    goal: str
    backstory: str
    tools: List[str] = Field(default_factory=list)
    allow_delegation: bool = False
    verbose: bool = False
    max_iter: Optional[int] = None


class TaskPlan(BaseModel):
    """Structured definition for a task created by the planner."""

    name: str
    description: str
    expected_output: str
    agent: str
    tools: List[str] = Field(default_factory=list)
    async_execution: bool = False


class CrewPlan(BaseModel):
    """Complete plan generated by the planner model."""

    summary: str
    agents: List[AgentPlan]
    tasks: List[TaskPlan]
    process: str = "sequential"

    def process_enum(self) -> Process:
        mapping = {
            "sequential": Process.sequential,
            "hierarchical": Process.hierarchical,
            "parallel": Process.parallel,
        }
        return mapping.get(self.process.lower(), Process.sequential)


@dataclass
class BuiltCrew:
    plan: CrewPlan
    crew: Crew


class PlanGenerationError(RuntimeError):
    """Raised when the planner produces an invalid or unparsable response."""


class DynamicCrewOrchestrator:
    """Build and execute crews dynamically based on a single user prompt."""

    def __init__(
        self,
        planner_llm: BaseChatModel,
        agent_llm_factory: Callable[[AgentPlan], BaseChatModel],
        tool_registry: ToolRegistry,
        *,
        planner_instructions: Optional[str] = None,
        verbose: bool = False,
    ) -> None:
        self.planner_llm = planner_llm
        self.agent_llm_factory = agent_llm_factory
        self.tool_registry = tool_registry
        self.verbose = verbose
        self._planner_instructions = planner_instructions or self._default_planner_instructions()

    @staticmethod
    def _default_planner_instructions() -> str:
        return (
            "You are an expert project manager that assembles specialised AI "
            "agents to solve complex problems. Based on the user's problem you "
            "must describe the agents, tasks and tools required to solve it. "
            "Always answer with a JSON object following the schema provided "
            "in the system message."
        )

    def plan(self, prompt: str) -> CrewPlan:
        """Generate a :class:`CrewPlan` for ``prompt`` using the planner LLM."""

        logger.debug("Planning dynamic crew for prompt: %s", prompt)
        messages = [
            SystemMessage(
                content=(
                    "You will receive a problem description from the user. "
                    "Respond **only** with valid JSON that matches this schema:\n"
                    "{\n"
                    "  \"summary\": str,\n"
                    "  \"process\": str,  // sequential | hierarchical | parallel\n"
                    "  \"agents\": [\n"
                    "    {\n"
                    "      \"name\": str,\n"
                    "      \"role\": str,\n"
                    "      \"goal\": str,\n"
                    "      \"backstory\": str,\n"
                    "      \"tools\": [str],\n"
                    "      \"allow_delegation\": bool,\n"
                    "      \"verbose\": bool,\n"
                    "      \"max_iter\": int | null\n"
                    "    }\n"
                    "  ],\n"
                    "  \"tasks\": [\n"
                    "    {\n"
                    "      \"name\": str,\n"
                    "      \"description\": str,\n"
                    "      \"expected_output\": str,\n"
                    "      \"agent\": str,  // reference to an agent name\n"
                    "      \"tools\": [str],\n"
                    "      \"async_execution\": bool\n"
                    "    }\n"
                    "  ]\n"
                    "}\n"
                    "Only include tools that are present in the provided list. "
                    "If none of the available tools are useful, return an empty "
                    "list for \"tools\".\n\n"
                    f"Available tools: {', '.join(self.tool_registry.available())}\n\n"
                    f"{self._planner_instructions}"
                )
            ),
            HumanMessage(content=prompt),
        ]
        response = self.planner_llm.invoke(messages)
        raw_plan = getattr(response, "content", response)
        try:
            return self._parse_plan(raw_plan)
        except ValidationError as exc:  # pragma: no cover - defensive
            raise PlanGenerationError(
                f"Planner produced invalid plan: {exc}\nRaw response: {raw_plan}"
            ) from exc
        except json.JSONDecodeError as exc:  # pragma: no cover - defensive
            raise PlanGenerationError(
                f"Planner did not return valid JSON. Raw response: {raw_plan}"
            ) from exc

    def _parse_plan(self, raw_plan: Any) -> CrewPlan:
        if isinstance(raw_plan, CrewPlan):
            return raw_plan
        if isinstance(raw_plan, dict):
            data = raw_plan
        else:
            text = str(raw_plan).strip()
            start = text.find("{")
            end = text.rfind("}")
            if start == -1 or end == -1:
                raise json.JSONDecodeError("Missing JSON object", text, 0)
            data = json.loads(text[start : end + 1])
        plan = CrewPlan.model_validate(data)
        return plan

    def build_crew(self, plan: CrewPlan) -> BuiltCrew:
        """Instantiate crewAI objects based on ``plan``."""

        agent_lookup: Dict[str, Agent] = {}
        for agent_plan in plan.agents:
            tools = [
                self.tool_registry.get(tool_name)
                for tool_name in agent_plan.tools
                if self.tool_registry.has(tool_name)
            ]
            if missing := [
                name for name in agent_plan.tools if not self.tool_registry.has(name)
            ]:
                logger.warning("Ignoring unknown tools for agent %s: %s", agent_plan.name, missing)
            agent = Agent(
                name=agent_plan.name,
                role=agent_plan.role,
                goal=agent_plan.goal,
                backstory=agent_plan.backstory,
                allow_delegation=agent_plan.allow_delegation,
                verbose=agent_plan.verbose or self.verbose,
                tools=tools,
                llm=self.agent_llm_factory(agent_plan),
                max_iter=agent_plan.max_iter,
            )
            agent_lookup[agent_plan.name] = agent

        tasks: List[Task] = []
        for task_plan in plan.tasks:
            try:
                assigned_agent = agent_lookup[task_plan.agent]
            except KeyError as exc:
                raise PlanGenerationError(
                    f"Task '{task_plan.name}' references unknown agent '{task_plan.agent}'."
                ) from exc
            task_tools = [
                self.tool_registry.get(tool_name)
                for tool_name in task_plan.tools
                if self.tool_registry.has(tool_name)
            ]
            task = Task(
                name=task_plan.name,
                description=task_plan.description,
                expected_output=task_plan.expected_output,
                agent=assigned_agent,
                tools=task_tools or None,
                async_execution=task_plan.async_execution,
            )
            tasks.append(task)

        crew = Crew(
            agents=list(agent_lookup.values()),
            tasks=tasks,
            process=plan.process_enum(),
            verbose=self.verbose,
        )
        return BuiltCrew(plan=plan, crew=crew)

    def run(self, prompt: str, *, kickoff_inputs: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Plan, build and execute a crew to respond to ``prompt``.

        Returns
        -------
        dict
            A dictionary with the planning information and execution result. The
            ``plan`` key contains the structured :class:`CrewPlan` and the
            ``result`` key holds the raw crew output.
        """

        plan = self.plan(prompt)
        built = self.build_crew(plan)
        inputs = {"problem": prompt}
        if kickoff_inputs:
            inputs.update(kickoff_inputs)
        result = built.crew.kickoff(inputs=inputs)
        return {"plan": plan, "result": result}
